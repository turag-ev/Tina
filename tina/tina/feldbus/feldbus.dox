/** @defgroup feldbus Feldbus
 *
 * %TURAG Feldbus ist eine Busspezifikation, die auf RS485 aufsetzt. 
 * Es besteht aus einem Basis-Protokoll, das den konfliktfreien
 * Betrieb aller Geräte auf dem Bus gewährleistet, sowie aus spezialisierten
 * Anwendungsprotokollen, die bestimmte Geräteklassen mit spezialisierten
 * Eigenschaften definieren.
 * 
 * Die Spezifikation von Basis- und Anwendungsprotokollen ist im 
 * [Wiki](https://intern.turag.de/wiki/doku.php/id,04_programmierung;protokolle_busse;turag-simplebus) zu finden.
 * 
 * Dieses Modul enthält in seinen jeweiligen Submodulen fertige Quellcodes
 * für Slave- und Hostseite, die konform zu den Spezifikationen des Basis- und
 * der Anwendungsprotokolle ist. Insbesondere bei der Entwicklung neuer Slave-Geräte
 * ist dies ein großer Vorteil. Ein weiteres Submodul enthält die von den ersten beiden
 * Modulen benötigten Header mit Steuer-Definitionen (entsprechend der Protokoll-Spezifikationen).
 *
 * 
 * @defgroup feldbus-slave Slave Implementierungen [C]
 * @ingroup feldbus
 * 
 * Um die Entwicklung neuer TURAG-Feldbus Geräte zu beschleunigen und die Kompatibilität
 * zu gewährleisten, gibt es fertige und plattformunabhängige Implementierungen für Basis-
 * und Anwendungsprotokolle. Diese nutzen zwar einige der in TinA enthaltenen Algorithmen,
 * benötigen aber kein Betriebssystem oder Thread-Support und sind daher für kleinere
 * Controller wie AVR ATmega/Xmega geeignet (und auch vorgesehen).
 * 
 * @section felbus-slave-struktur-basis Struktur der Basis-Implementierung
 * 
 * \image html feldbus-slave.png "Strukturschema der TURAG-Feldbus-Basisimplementierung"
 * Die Basis-Implementierung sitzt zwischen Hardware und Firmware des Slave-Gerätes. 
 * Die Kommunikation mit der Hardware geschieht über ein Hardware-Interface, während für die
 * Firmware des Gerätes mit dem Protokoll-Interface eine abstrakte Schnittstelle bereitsteht,
 * um mit geringem Aufwand über den TURAG-Feldbus kommunizieren zu können.
 * 
 * Beide Interfaces sind jeweils teilweise implementiert - der andere Teil muss 
 * vom Entwickler des Slave-Gerätes bereitgestellt werden, so wie dies im Strukturschema 
 * dargestellt ist.
 * 
 * Anhand des Strukturschemas lässt sich die Arbeitsweise der Basis-Implementierung auch 
 * gut beschreiben. Der Entwickler des Gerätes ruft zu einem frühen Zeitpunkt 
 * turag_feldbus_slave_init() auf. Das initialisiert interne Strukturen und ruft seinerseits
 * turag_feldbus_hardware_init() auf, welches die UART-Peripherie des Controllers initialisieren 
 * sollte. Danach müssen (falls das der Controller verlangt) die Interrupts global aktiviert 
 * werden. Ab diesem Zeitpunkt werden eintreffende Daten im Hardware-Interfaceteil der
 * Basis-Implementierung verarbeitet. Da die Paket-Erkennung im Kontext von Interrupts
 * ausgeführt wird, wird an dieser Stelle nur ein Flag gesetzt, sobald ein gültiges Paket
 * erkannt wurde. Die eigentliche Auswertung eines angekommenen Paketes wird erst gestartet,
 * wenn turag_feldbus_do_processing() aufgerufen wird. Diese Funktion deaktiviert 
 * temporär den Empfang neuer Daten, kopiert das empfangene Paket in einen Zwischenpuffer
 * und aktiviert die Kommunikation wieder. Dann wird, je nach Pakettyp, 
 * turag_feldbus_slave_process_package() oder turag_feldbus_slave_process_broadcast() 
 * aufgerufen und das Paket wird so verarbeitet, wie das die Firmware des Slave-Gerätes
 * vorsieht.
 * 
 * Diese strikte Trennung der Kommunikation zwischen Empfang der Daten in Interrupts
 * und Verarbeitung im Kontext von main() hat zwei Vorteile:
 * - Die Verweildauer in Interrupts wird reduziert, was bei zeitkritischen 
 * Anwendungen wie Motorregelungen relevant sein kann. Der Entwickler muss sich 
 * dadurch weniger Gedanken über die Laufzeit der Paketverarbeitung machen, da 
 * diese lediglich ein Teil von main() ist.
 * - Da der komplette Datenaustausch zwischen Interrupts und main-Kontext 
 * von der Basis-Implementierung übernommen wird, muss der Entwickler keine 
 * weiteren Vorkehrungen treffen - es ist weder nötig Variablen als volatile
 * zu deklarieren, noch nicht-atomare Schreiboperationen vor Unterbrechung durch
 * Interrupts zu schützen (das gilt natürlich nur, solange das Slave-Gerät nicht
 * selbst noch weitere Interrupts benutzt).
 * 
 * **Wichtig**: damit sich das Slave-Gerät korrekt verhält, muss turag_feldbus_do_processing()
 * regelmäßig von der Hauptschleife aus aufgerufen werden.
 * 
 * Ein weiteres erwähnenswertes Feature ist der Uptime-Counter. Ein Timer des Slaves wird
 * so konfiguriert, dass er mit einer wählbaren Frequenz 
 * turag_feldbus_slave_increase_uptime_counter() aufruft. Der Master kann die Laufzeit des
 * Slaves auslesen und so zum Beispiel Probleme in der Stromversorgung feststellen, was sich 
 * in Neustarts des Slaves und einem Zurücksetzen des Uptime-Counters äußern
 * würde. 
 * 
 * Wenn eine LED vorhanden ist, kann automatisch die Funktion
 * turag_feldbus_slave_toggle_led() aufgerufen werden. Das Blinkmuster ist dabei
 * (soweit möglich) unabhängig von der Timer-Frequenz und fungiert außerdem als Indikator
 * für die Stabilität der Kommunikation: das Blinken der LED wird ausgesetzt, solange
 * im Gerät ein unverarbeitetes Paket vorliegt (zum Beispiel weil turag_feldbus_do_processing())
 * nicht oder nur zu selten aufgerufen wird. Zeigt die LED also ein unregelmäßiges Blinkmuster an
 * oder blinkt sie sogar gar nicht, gibt es Kommunikationsprobleme oder der Gerät
 * ist abgestürzt.
 * 
 * @section felbus-slave-struktur-anwendung Struktur der Anwendungsprotokoll-Implementierungen
 * Die Implementierungen der Anwendungsprotokolle führen im Allgemeinen zwei Änderungen
 * ein:
 * - statt turag_feldbus_slave_init() muss eine spezialisierte Initialisierungsroutine
 * aufgerufen werden
 * - turag_feldbus_slave_process_package() und turag_feldbus_slave_process_broadcast() 
 * werden vom Anwendungsprotokoll selbst implementiert, während die Firmware das 
 * Slave-Gerätes spezialisiertere Funktionen zu implementieren hat.
 * 
 * An der Notwendigkeit, turag_feldbus_do_processing() zyklisch aufzurufen,
 * ändert sich normalerweise nichts.
 * 
 * @section feldbus-slave-implementierungsanleitung HowTo: Softwaregerüst für ein neues Feldbusgerät erstellen
 * 1. Verzeichnisstruktur erstellen:
 * \image html feldbus-device-file-structure.png
 * 2. Als Basis für die Konfigurationsdatei sollte eine Kopie der Datei programmierung/tina/tina/feldbus/slave/feldbus_config.h benutzt werden.
 *    Wichtig ist hierbei das korrekte includieren des passenden Protokoll-Headers. Basiert das Gerät auf einem Anwendungsprotokoll 
 *    (statt nur des Basis-Protokolls) werden evt. weitere Definitionen nötig, die in der Beispieldatei nicht enthalten sind. 
 * 3. Die Funktionen des Hardware-Interfaces müssen für die Plattform bereitgestellt werden (feldbus_hardware_driver.c). 
 * 4. Die Funktionen des Protokoll-Interfaces müssen gemäß dem Strukturschema bereitgestellt werden (main.c).
 * 5. Ein Makefile ist nötig, welches
 *  - alle Dateien des src-Ordners compiliert
 *  - die Feldbus-Slave-Quelldateien compiliert (es kann problemlos der komplette Ordner compiliert werden, da
 *    nur Code des gewählten Protokolls benutzt wird)
 *  - die Quelldateien des eingestellten Checksummen-Algorithmus compiliert
 *  - den tina- und den src-Ordner als Include-Pfad konfiguriert
 * 
 * Das Makefile kann üblicherweise aus alten Projekten übernommen und entsprechend angepasst werden.
 * 
 * **Wichtig:** zumindest die Datei, die die ISRs enthält (also feldbus_hardware_driver.c) muss mit -O3
 * compiliert werden! Nur dann beginnt der Compiler automatisch Aufrufe von kleinen Funktionen zu inlinen,
 * was im Falle der ISRs wichtig ist. Ansonsten leidet die Performance stark.
 * 
 * **Wichtig:** Die von der Basis-Implementerung bereitgestellten Hardware-Funktionen 
 * (wie z.B. turag_feldbus_slave_receive_timeout_occured()) gehen davon aus,
 * dass ihre Ausführung nicht unterbrochen werden kann. Die Interrupts, die diese Funktionen
 * aufrefen, sollten also nicht von anderen Interrupts unterbrochen werden können.
 * 
 * @section feldbus-slave-beispiel-hardware-interface Beispiel-Implementierung des Hardware-Interfaces
 * Im folgenden wird ein Beispiel betrachtet, wie die Implementierung des Hardware-Interfaces für einen
 * ATmega88 aussehen kann.
 * 
 * Neben den AVR-Headern wird der entsprechende Protokoll-Header eingebunden.
 * \snippet feldbus_hardware_driver.c Includes
 * 
 * Als nächstes folgen einige Definitionen. Insbesondere die letzten beiden werden
 * üblicherweise über das Makefile global im Projekt bereitgestellt.
 * \snippet feldbus_hardware_driver.c Definitions
 * 
 * Danach ein paar hilfreiche Makros:
 * \snippet feldbus_hardware_driver.c Helper macros
 * 
 * Einen großen Teil der Implementierung nimmt die Bereitstellung der notwendigen
 * Hardware-Interface-Funktionen ein, darunter die Funktion \ref turag_feldbus_hardware_init() 
 * zum Initialisieren der Peripherie des Controllers.
 * \snippet feldbus_hardware_driver.c Required hardware functions
 * 
 * Zu guter letzt folgen die ISR-Handler, die die Ausführung lediglich an die entsprechenden
 * Funktionen der Basis-Implementierung weiterreichen:
 * \snippet feldbus_hardware_driver.c Interrupts
 * 
 * @section feldbus-slave-korrekt-includen Korrektes includieren der Header
 * 
 * Die folgenden Graphen zeigen an, welche Header sinnvollerweise von welchen Dateien includiert
 * werden sollten. Blau umrandete Dateien sind Teil von TinA, schwarz umrandete solche,
 * die der Entwickler des Slave-Gerätes bereitstellt.
 * 
 * Hervorzuheben sind folgende Punkte:
 * - die Header von Basis- und Anwendungsprotokoll sind auf die Existenz von 
 * "feldbus_config.h" angewiesen und die Tatsache, dass dieser Header auch 
 * den richtigen Protokollheader includiert.
 * - setzt das Slave-Gerät direkt auf dem Basis-Protokoll auf, so wird stets "feldbus.h" 
 * includiert, anonsten der entsprechende Header des Anwendungsprotokolls.
 * 
 * \dot
 * digraph G {
 * 
 * node [shape="box", fontname="Helvetica", fontsize="12"];
 * 
 * subgraph cluster0 {
 * 		a1 -> a2 -> a3 -> a4;
 * 		label = "Basis-Implementierung";
 * 		fontname="Helvetica";
 * 		fontsize="14";
 * 		color="white";
 * }
 * 
 * subgraph cluster1 {
 * 		b1 -> b2 ->b3 -> b4 -> b5 -> b6; 
 * 		label ="Stellantriebe-Anwendungsprotokoll"
 * 		fontname="Helvetica";
 * 		fontsize="14";
 * 		color="white";
 * }
 * 
 * a1 [label="main.c; andere Dateien"];
 * a2 [label="feldbus.h", color="blue"];
 * a3 [label="feldbus_config.h"];
 * a4 [label="turag_feldbus_bus_protokoll.h", color="blue"];
 * 
 * b1 [label="main.c; andere Dateien"];
 * b2 [label="feldbus_stellantriebe.h", color="blue"];
 * b3 [label="feldbus.h", color="blue"];
 * b4 [label="feldbus_config.h"];
 * b5 [label="turag_feldbus_fuer_stellantriebe.h", color="blue"];
 * b6 [label="turag_feldbus_bus_protokoll.h", color="blue"];
 * 
 * 
 * }
 * \enddot
 * 
 * @section feldbus-slave-neues-anwendungsprotokoll Implementieren eines neuen Anwendungsprotokolls
 * Ein neues Anwendungsprotokoll ist normalerweise dann von Nöten, wenn eine 
 * neue Gerätegruppe entwickelt werden soll. Die Entwicklung eines neuen
 * Anwendungsprotokolls umfasst mehrere Schritte:
 * 
 * 1. Im [Wiki](https://intern.turag.de/wiki/doku.php/id,04_programmierung;protokolle_busse;turag-simplebus#anwendungs-protokolle) 
 * eine Seite mit den Spezifikationsdetails des Anwendungsprotokolls anlegen und auf der 
 * Hauptseite verlinken
 * 2. In turag_feldbus_bus_protokoll.h wird die ID des neuen Protokolls eingetragen
 * 3. Für das neue Protokoll wird ein eigener Protokollheader angelegt, der die in der Spezifikation
 * definierten Werte und IDs enthält
 * 4. Eine Slave-Implementierung des Anwendungsprotokolls wird angelegt, die üblicherweise
 * aus einem Header und einer Quelldatei besteht.
 * 5. Hostklassen zur Kommunikation mit den neuen Geräten werden angelegt
 * 6. In der TURAG-Console wird Support für den Gerätetyp eingebaut, was gleich 
 * zur Verifizierung der Host-Klassen benutzt werden kann.
 * 
 * Wenn möglich, sollte \ref _Static_assert benutzt werden, um sicherzustellen
 * dass mit \ref TURAG_FELDBUS_SLAVE_CONFIG_BUFFER_SIZE ein ausreichend großer
 * Transmit-Buffer konfiguriert ist, da es ansonsten zu Pufferüberläufen kommen kann.
 * 
 * 
 * @defgroup feldbus-host Host Implementierungen [C++]
 * @ingroup feldbus
 * 
 * Host-Klassen, die zur Kommunikation mit Busgeräten benutzt werden können.
 * 
 * Die Basis aller Hosts-Klassen ist \ref TURAG::Feldbus::Device, das masterseitigen 
 * Support für das Basis-Protokoll bereitstellt.
 * 
 * Das Verhalten des Masters kann mit einigen Definitionen angepasst werden, für die
 * sinnvolle Standardwerte eingestellt sind. Bei Bedarf können diese über die TinA-Konfiguration
 * entsprechend überschrieben werden.
 *
 * Die plattformabhängige Schnittstelle zur Hardware ist in rs485.h definiert.
 *
 * \section feldbus-host-configurability Konfigurierbarkeit
 * - \ref TURAG_USE_TURAG_FELDBUS_HOST muss auf 1 definiert sein.
 * - \ref TURAG_FELDBUS_AKTOR_STRUCTURED_OUTPUT_AVAILABLE ist optional.
 *
 * 
 * \section feldbus-host-threadsafety Thread-Safety
 * \note Generell ist aus Gründen der Einfachheit zu empfehlen, alle Host-Klassen
 * exklusiv von einem einzigen %Thread aus zu benutzen und den Austausch von Daten
 * über andere Mechanismen zu gewährleisten. Dadurch ist der Zugriff auf den 
 * Bus geordnet und die Komplexität des System wird nicht unnnötig gesteigert.
 * Die folgenden Informationen sind der Vollständigkeit halber angegeben.
 * 
 * Damit der Buszugriff mit mehreren Threads reibungslos funktioniert, sind
 * folgende Voraussetzungen zu erfüllen:
 * - Host-Klassen müssen mindestens reentrant sein
 * - Zugriff auf die Bus-Hardware muss synchronisert sein
 * - Bus-Transaktionen müssen atomaren Charakter besitzen.
 * 
 * Die Host-Klassen sind reentrant, aber nicht thread-safe. Das heißt, der Zugriff 
 * auf eine Instanz einer Klasse muss manuell synchronisiert werden. Unproblematisch 
 * ist hingegen die Verwendung verschiedener Instanzen einer Klasse in verschiedenen Threads.
 * Dies ist eine übliche Einschränkung, da die Gewährleistung von Threadsicherheit
 * für jede Funktion einen zu großen Overhead mit sich bringen würde. Soll ein Busgerät
 * von mehreren Threads angesprochen werden, so müssen entweder zwei Instanzen 
 * für jeden %Thread angelegt werden oder jeder Aufruf von nicht-immutable Funktionen muss
 * synchronisert werden. Welche Variante sinnvoller ist, hängt stark von den Details
 * der entsprechenden Klasse ab.
 * 
 * Die Synchronisierung des Zugriffs auf die Bus-Hardware obliegt der Platform-Implementierung
 * der Funktion turag_rs485_transceive(), welche das Versenden und den Empfang einer bestimmten 
 * Datenmenge bereitstellt.
 * 
 * Atomizität der Bus-Transaktionen bedeutet, dass zu einem Befehl gehörende 
 * Datenübertragungen nicht von fremden unterbrochen werden können. Dies wird zu einem
 * großen Teil schon von der Anforderung gewährleistet, dass alle Protokolle zustandslos
 * sein müssen, wodurch es unproblematisch ist, wenn Pakete zwischeneinander gemischt werden.
 * In der Praxis bedeutet das üblicherweise, dass eine Funktion einer Hostklasse maximal 
 * einmal turag_rs485_transceive() aufrufen kann. 
 * 
 * 
 * 
 * 
 * @defgroup feldbus-protocol Protokoll-Definitionen [C/C++]
 * @ingroup feldbus
 * 
 * Protokoll-Definitionen, die von Host- und Slave-Implementierungen 
 * gleichermaßen benutzt werden.
 * 
 * 
 *
 */ 
